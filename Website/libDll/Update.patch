Index: Basic Shapes/SvgCircle.cs
===================================================================
--- Basic Shapes/SvgCircle.cs	(revision 75832)
+++ Basic Shapes/SvgCircle.cs	(working copy)
@@ -23,7 +23,7 @@
         /// <value>The center.</value>
         public SvgPoint Center
         {
-            get { return new SvgPoint(this.CenterX, this.CenterY); }
+            get { return new SvgPoint(CenterX, CenterY); }
         }
 
         /// <summary>
Index: Basic Shapes/SvgPolyline.cs
===================================================================
--- Basic Shapes/SvgPolyline.cs	(revision 75832)
+++ Basic Shapes/SvgPolyline.cs	(working copy)
@@ -17,15 +17,15 @@
         {
             get
             {
-                if (this._path == null || this.IsPathDirty)
+                if (_path == null || IsPathDirty)
                 {
-                    this._path = new GraphicsPath();
+                    _path = new GraphicsPath();
 
                     try
                     {
-                        for (int i = 0; i < this._points.Count; i += 2)
+                        for (int i = 0; i < _points.Count; i += 2)
                         {
-                            PointF endPoint = new PointF(this._points[i].ToDeviceValue(this), this._points[i + 1].ToDeviceValue(this));
+                            PointF endPoint = new PointF(_points[i].ToDeviceValue(this), _points[i + 1].ToDeviceValue(this));
 
                             // TODO: Remove unrequired first line
                             if (_path.PointCount == 0)
@@ -42,9 +42,9 @@
                     {
                         Trace.TraceError("Error rendering points: " + exc.Message);
                     }
-                    this.IsPathDirty = false;
+                    IsPathDirty = false;
                 }
-                return this._path;
+                return _path;
             }
         }
     }
Index: Basic Shapes/SvgVisibility.cs
===================================================================
--- Basic Shapes/SvgVisibility.cs	(revision 0)
+++ Basic Shapes/SvgVisibility.cs	(revision 0)
@@ -0,0 +1,9 @@
+namespace Svg
+{
+    public enum SvgVisibility
+    {
+        Visible,
+        Hidden,
+        Inherit
+    }
+}
\ No newline at end of file
Index: Basic Shapes/SvgVisualElement.cs
===================================================================
--- Basic Shapes/SvgVisualElement.cs	(revision 75832)
+++ Basic Shapes/SvgVisualElement.cs	(working copy)
@@ -84,29 +84,32 @@
         /// <param name="graphics">The <see cref="SvgRenderer"/> object to render to.</param>
         protected override void Render(SvgRenderer renderer)
         {
-            if (this.Path != null && this.Visible)
+            if (Path != null && Visible == SvgVisibility.Visible)
             {
-                this.PushTransforms(renderer);
-                this.SetClip(renderer);
+                PushTransforms(renderer);
+                SetClip(renderer);
 
                 // If this element needs smoothing enabled turn anti-aliasing on
-                if (this.RequiresSmoothRendering)
+                if (RequiresSmoothRendering)
                 {
                     renderer.SmoothingMode = SmoothingMode.AntiAlias;
                 }
 
-                this.RenderFill(renderer);
-                this.RenderStroke(renderer);
+                RenderFill(renderer);
+                RenderStroke(renderer);
 
                 // Reset the smoothing mode
-                if (this.RequiresSmoothRendering && renderer.SmoothingMode == SmoothingMode.AntiAlias)
+                if (RequiresSmoothRendering && renderer.SmoothingMode == SmoothingMode.AntiAlias)
                 {
                     renderer.SmoothingMode = SmoothingMode.Default;
                 }
 
-                this.ResetClip(renderer);
-                this.PopTransforms(renderer);
+                ResetClip(renderer);
+                PopTransforms(renderer);
             }
+			
+			RenderChildren(renderer);
+			
         }
 
         /// <summary>
@@ -115,13 +118,13 @@
         /// <param name="renderer">The <see cref="SvgRenderer"/> object to render to.</param>
         protected internal virtual void RenderFill(SvgRenderer renderer)
         {
-            if (this.Fill != null)
+            if (Fill != null)
             {
-                using (Brush brush = this.Fill.GetBrush(this, this.FillOpacity))
+                using (Brush brush = Fill.GetBrush(this, FillOpacity))
                 {
                     if (brush != null)
                     {
-                        renderer.FillPath(brush, this.Path);
+                        renderer.FillPath(brush, Path);
                     }
                 }
             }
@@ -135,17 +138,24 @@
         {
             if (this.Stroke != null)
             {
-                float strokeWidth = this.StrokeWidth.ToDeviceValue(this);
-                using (var pen = new Pen(this.Stroke.GetBrush(this, this.StrokeOpacity), strokeWidth))
-                {
-                    if (this.StrokeDashArray != null && this.StrokeDashArray.Count > 0)
-                    {
-                        /* divide by stroke width - GDI behaviour that I don't quite understand yet.*/
-                        pen.DashPattern = this.StrokeDashArray.ConvertAll(u => u.Value/((strokeWidth <= 0) ? 1 : strokeWidth)).ToArray();
-                    }
-
-                    renderer.DrawPath(pen, this.Path);
-                }
+				float strokeWidth = StrokeWidth.ToDeviceValue(this);
+				Brush brush = Stroke.GetBrush(this, StrokeOpacity);
+				if (brush != null)
+				{
+					using (Pen pen = new Pen(brush, strokeWidth))
+					{
+						if (pen != null)
+						{
+							if (this.StrokeDashArray != null)
+							{
+								/* divide by stroke width - GDI behaviour that I don't quite understand yet.*/
+								List<float> strokes = this.StrokeDashArray.ConvertAll(u => u.Value / ((strokeWidth <= 0) ? 1 : strokeWidth));
+								pen.DashPattern = strokes.ToArray();
+							}
+							renderer.DrawPath(pen, this.Path);
+						}
+					}
+				}
             }
         }
 
Index: Basic Shapes/SvgVisualElementStyle.cs
===================================================================
--- Basic Shapes/SvgVisualElementStyle.cs	(revision 75832)
+++ Basic Shapes/SvgVisualElementStyle.cs	(working copy)
@@ -19,10 +19,10 @@
         /// Gets or sets a value to determine whether the element will be rendered.
         /// </summary>
         [SvgAttribute("visibility")]
-        public virtual bool Visible
+        public virtual SvgVisibility Visible
         {
-            get { return (this.Attributes["Visible"] == null) ? true : (bool)this.Attributes["Visible"]; }
-            set { this.Attributes["Visible"] = value; }
+            get { return (Attributes["Visible"] == null) ? SvgVisibility.Visible : (SvgVisibility)Attributes["Visible"]; }
+            set { Attributes["Visible"] = value; }
         }
 
         /// <summary>
@@ -31,8 +31,8 @@
         [SvgAttribute("fill")]
         public virtual SvgPaintServer Fill
         {
-            get { return (this.Attributes["Fill"] == null) ? new SvgColourServer() : (SvgPaintServer)this.Attributes["Fill"]; }
-            set { this.Attributes["Fill"] = value; }
+            get { return (SvgPaintServer)Attributes["Fill"] ?? new SvgColourServer(); }
+            set { Attributes["Fill"] = value; }
         }
 
         /// <summary>
@@ -41,8 +41,8 @@
         [SvgAttribute("stroke")]
         public virtual SvgPaintServer Stroke
         {
-            get { return (this.Attributes["Stroke"] == null) ? null : (SvgPaintServer)this.Attributes["Stroke"]; }
-            set { this.Attributes["Stroke"] = value; }
+            get { return (Attributes["Stroke"] == null) ? null : (SvgPaintServer)Attributes["Stroke"]; }
+            set { Attributes["Stroke"] = value; }
         }
 
         [SvgAttribute("fill-rule")]
@@ -68,22 +68,22 @@
         [SvgAttribute("stroke-width")]
         public virtual SvgUnit StrokeWidth
         {
-            get { return (this.Attributes["StrokeWidth"] == null) ? new SvgUnit(1.0f) : (SvgUnit)this.Attributes["StrokeWidth"]; }
-            set { this.Attributes["StrokeWidth"] = value; }
+            get { return (Attributes["StrokeWidth"] == null) ? new SvgUnit(1.0f) : (SvgUnit)this.Attributes["StrokeWidth"]; }
+            set { Attributes["StrokeWidth"] = value; }
         }
 
         [SvgAttribute("stroke-linecap")]
         public virtual SvgStrokeLineCap StrokeLineCap
         {
-            get { return (this.Attributes["StrokeLineCap"] == null) ? SvgStrokeLineCap.Butt : (SvgStrokeLineCap)this.Attributes["StrokeLineCap"]; }
-            set { this.Attributes["StrokeLineCap"] = value; }
+            get { return (Attributes["StrokeLineCap"] == null) ? SvgStrokeLineCap.Butt : (SvgStrokeLineCap)Attributes["StrokeLineCap"]; }
+            set { Attributes["StrokeLineCap"] = value; }
         }
 
         [SvgAttribute("stroke-linejoin")]
         public virtual SvgStrokeLineJoin StrokeLineJoin
         {
-            get { return (this.Attributes["StrokeLineJoin"] == null) ? SvgStrokeLineJoin.Miter : (SvgStrokeLineJoin)this.Attributes["StrokeLineJoin"]; }
-            set { this.Attributes["StrokeLineJoin"] = value; }
+            get { return (Attributes["StrokeLineJoin"] == null) ? SvgStrokeLineJoin.Miter : (SvgStrokeLineJoin)Attributes["StrokeLineJoin"]; }
+            set { Attributes["StrokeLineJoin"] = value; }
         }
 
         [SvgAttribute("stroke-miterlimit")]
Index: DataTypes/SvgUnitCollection.cs
===================================================================
--- DataTypes/SvgUnitCollection.cs	(revision 75832)
+++ DataTypes/SvgUnitCollection.cs	(working copy)
@@ -34,6 +34,8 @@
         {
             if (value is string)
             {
+				if ((value as String) == "none")
+					return null;
                 string[] points = ((string)value).Trim().Split(new char[] { ',', ' ', '\r', '\n', '\t' }, StringSplitOptions.RemoveEmptyEntries);
                 SvgUnitCollection units = new SvgUnitCollection();
 
Index: DataTypes/SvgUnitConverter.cs
===================================================================
--- DataTypes/SvgUnitConverter.cs	(revision 75832)
+++ DataTypes/SvgUnitConverter.cs	(working copy)
@@ -36,8 +36,11 @@
             {
                 if (char.IsLetter(unit[i]) || unit[i] == '%')
                 {
-                    identifierIndex = i;
-                    break;
+                    if (unit[i] != 'e' || i >= (unit.Length - 1) || unit[i + 1] == 'm') // Support for exponential form added
+                    {
+                        identifierIndex = i;
+                        break;
+                    }
                 }
             }
 
Index: Document Structure/SvgDescription.cs
===================================================================
--- Document Structure/SvgDescription.cs	(revision 75832)
+++ Document Structure/SvgDescription.cs	(working copy)
@@ -9,17 +9,11 @@
     [SvgElement("desc")]
     public class SvgDescription : SvgElement
     {
-        private string _text;
+        public string Text { get; set; }
 
-        public string Text
-        {
-            get { return this._text; }
-            set { this._text = value; }
-        }
-
         public override string ToString()
         {
-            return this.Text;
+            return Text;
         }
     }
 }
\ No newline at end of file
Index: Document Structure/SvgFragment.cs
===================================================================
--- Document Structure/SvgFragment.cs	(revision 75832)
+++ Document Structure/SvgFragment.cs	(working copy)
@@ -14,10 +14,6 @@
     [SvgElement("svg")]
     public class SvgFragment : SvgElement, ISvgViewPort
     {
-        private SvgUnit _width;
-        private SvgUnit _height;
-        private SvgViewBox _viewBox;
-
         /// <summary>
         /// Gets the SVG namespace string.
         /// </summary>
@@ -28,33 +24,21 @@
         /// </summary>
         /// <value>The width.</value>
         [SvgAttribute("width")]
-        public SvgUnit Width
-        {
-            get { return this._width; }
-            set { this._width = value; }
-        }
+        public SvgUnit Width { get; set; }
 
         /// <summary>
         /// Gets or sets the height of the fragment.
         /// </summary>
         /// <value>The height.</value>
         [SvgAttribute("height")]
-        public SvgUnit Height
-        {
-            get { return this._height; }
-            set { this._height = value; }
-        }
+        public SvgUnit Height { get; set; }
 
         /// <summary>
         /// Gets or sets the viewport of the element.
         /// </summary>
         /// <value></value>
         [SvgAttribute("viewBox")]
-        public SvgViewBox ViewBox
-        {
-            get { return this._viewBox; }
-            set { this._viewBox = value; }
-        }
+        public SvgViewBox ViewBox { get; set; }
 
         /// <summary>
         /// Applies the required transforms to <see cref="SvgRenderer"/>.
@@ -64,14 +48,14 @@
         {
             base.PushTransforms(renderer);
 
-            if (!this.ViewBox.Equals(SvgViewBox.Empty))
+            if (!ViewBox.Equals(SvgViewBox.Empty))
             {
-                if (this.ViewBox.MinX > 0 || this.ViewBox.MinY > 0)
+                if (ViewBox.MinX > 0 || ViewBox.MinY > 0)
                 {
-                    renderer.TranslateTransform(this.ViewBox.MinX, this.ViewBox.MinY, MatrixOrder.Append);
+                    renderer.TranslateTransform(ViewBox.MinX, ViewBox.MinY, MatrixOrder.Append);
                 }
 
-                renderer.ScaleTransform(this.Width.ToDeviceValue() / this.ViewBox.Width, this.Height.ToDeviceValue() / this.ViewBox.Height, MatrixOrder.Append);
+                renderer.ScaleTransform(Width.ToDeviceValue() / ViewBox.Width, Height.ToDeviceValue() / this.ViewBox.Height, MatrixOrder.Append);
             }
         }
 
@@ -80,9 +64,9 @@
         /// </summary>
         public SvgFragment()
         {
-            this._height = new SvgUnit(SvgUnitType.Percentage, 100.0f);
-            this._width = 1000.0f;
-            this.ViewBox = SvgViewBox.Empty;
+            Height = new SvgUnit(SvgUnitType.Percentage, 100.0f);
+            Width = 1000.0f;
+            ViewBox = SvgViewBox.Empty;
         }
     }
 }
\ No newline at end of file
Index: Document Structure/SvgGroup.cs
===================================================================
--- Document Structure/SvgGroup.cs	(revision 75832)
+++ Document Structure/SvgGroup.cs	(working copy)
@@ -37,12 +37,29 @@
         }
 
         /// <summary>
-        /// Gets the bounds of the element.
+        /// Gets the inherited union bounds of the SvgGroup element.
         /// </summary>
-        /// <value>The bounds.</value>
+        /// <value>The union inherited bounds.</value>
         public override System.Drawing.RectangleF Bounds
         {
-            get { return new System.Drawing.RectangleF(); }
+		
+            get
+			{
+				RectangleF bounds = RectangleF.Empty;
+				foreach(SvgElement child in this.Children)
+				{
+					if(child.GetType().BaseType == typeof(SvgGraphicsElement))
+					{
+						System.Drawing.RectangleF childBounds = ((SvgGraphicsElement)child).Bounds;
+						if(bounds == RectangleF.Empty)
+						{
+							bounds = childBounds;
+						}
+						bounds = RectangleF.Union(bounds, childBounds);
+					}
+				}
+				return bounds;
+			}
         }
 
         /// <summary>
@@ -51,11 +68,11 @@
         /// <param name="graphics">The <see cref="Graphics"/> object to render to.</param>
         protected override void Render(SvgRenderer renderer)
         {
-            this.PushTransforms(renderer);
-            this.SetClip(renderer);
+            PushTransforms(renderer);
+            SetClip(renderer);
             base.RenderChildren(renderer);
-            this.ResetClip(renderer);
-            this.PopTransforms(renderer);
+            ResetClip(renderer);
+            PopTransforms(renderer);
         }
     }
 }
\ No newline at end of file
Index: Document Structure/SvgUse.cs
===================================================================
--- Document Structure/SvgUse.cs	(revision 75832)
+++ Document Structure/SvgUse.cs	(working copy)
@@ -11,14 +11,8 @@
     [SvgElement("use")]
     public class SvgUse : SvgVisualElement
     {
-        private Uri _referencedElement;
-
         [SvgAttribute("href")]
-        public virtual Uri ReferencedElement
-        {
-            get { return this._referencedElement; }
-            set { this._referencedElement = value; }
-        }
+        public virtual Uri ReferencedElement { get; set; }
 
         [SvgAttribute("x")]
         public virtual SvgUnit X
@@ -59,10 +53,25 @@
                 return (element != null) ? element.Path : null;
             }
         }
-
+		/// <summary>
+        /// Gets the inherited bounds of the SvgUse element.
+        /// </summary>
+        /// <value>The inherited bounds.</value>
         public override System.Drawing.RectangleF Bounds
         {
-            get { return new System.Drawing.RectangleF(); }
+            get
+			{
+				SvgGraphicsElement element = (SvgGraphicsElement)this.OwnerDocument.IdManager.GetElementById(this.ReferencedElement);
+				Matrix transformMatrix = new Matrix();
+				if(this.Transforms != null)
+				{
+					foreach(Svg.Transforms.SvgTransform transformation in this.Transforms)
+					{
+						transformMatrix.Multiply(transformation.Matrix);
+					}
+				}
+				return new System.Drawing.RectangleF(element.Bounds.X + transformMatrix.OffsetX, element.Bounds.Y + transformMatrix.OffsetY, element.Bounds.Width, element.Bounds.Height);					
+			}
         }
 
         public override SvgElementCollection Children
@@ -83,10 +92,10 @@
             SvgVisualElement element = (SvgVisualElement)this.OwnerDocument.IdManager.GetElementById(this.ReferencedElement);
             // For the time of rendering we want the referenced element to inherit
             // this elements transforms
-            SvgElement parent = element._parent;
-            element._parent = this;
+            SvgElement parent = element.Parent;
+            element.Parent = this;
             element.RenderElement(renderer);
-            element._parent = parent;
+            element.Parent = parent;
 
             this.PopTransforms(renderer);
         }
Index: Exceptions/SvgException.cs
===================================================================
--- Exceptions/SvgException.cs	(revision 75832)
+++ Exceptions/SvgException.cs	(working copy)
@@ -1,7 +1,4 @@
 ﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 
 namespace Svg
 {
Index: Filter Effects/SvgFilter.cs
===================================================================
--- Filter Effects/SvgFilter.cs	(revision 75832)
+++ Filter Effects/SvgFilter.cs	(working copy)
@@ -23,8 +23,8 @@
         [SvgAttribute("width")]
         public SvgUnit Width
         {
-            get { return this.Attributes.GetAttribute<SvgUnit>("width"); }
-            set { this.Attributes["width"] = value; }
+            get { return Attributes.GetAttribute<SvgUnit>("width"); }
+            set { Attributes["width"] = value; }
         }
 
         /// <summary>
@@ -33,8 +33,8 @@
         [SvgAttribute("height")]
         public SvgUnit Height
         {
-            get { return this.Attributes.GetAttribute<SvgUnit>("height"); }
-            set { this.Attributes["height"] = value; }
+            get { return Attributes.GetAttribute<SvgUnit>("height"); }
+            set { Attributes["height"] = value; }
         }
 
         internal Dictionary<string, Func<SvgVisualElement, SvgRenderer, Bitmap>> Buffer { get; private set; }
@@ -44,7 +44,7 @@
         /// </summary>
         public SvgFilter()
         {
-            this.Buffer = new Dictionary<string, Func<SvgVisualElement, SvgRenderer, Bitmap>>();
+            Buffer = new Dictionary<string, Func<SvgVisualElement, SvgRenderer, Bitmap>>();
         }
 
         /// <summary>
@@ -72,7 +72,7 @@
             this.Buffer.Clear();
             this.PopulateDefaults(element, renderer);
 
-            IEnumerable<SvgFilterPrimitive> primitives = this.Children.OfType<SvgFilterPrimitive>();
+            IEnumerable<SvgFilterPrimitive> primitives = Children.OfType<SvgFilterPrimitive>();
 
             if (primitives.Count() > 0)
             {
@@ -82,43 +82,43 @@
                 }
 
                 // Render the final filtered image
-                renderer.DrawImageUnscaled(this.Buffer.Last().Value(element, renderer), new Point(0, 0));
+                renderer.DrawImageUnscaled(Buffer.Last().Value(element, renderer), new Point(0, 0));
             }
         }
 
         private void PopulateDefaults(SvgVisualElement element, SvgRenderer renderer)
         {
-            this.ResetDefaults();
+            ResetDefaults();
 
-            this.Buffer.Add(SvgFilterPrimitive.SourceGraphic, this.CreateSourceGraphic);
-            this.Buffer.Add(SvgFilterPrimitive.SourceAlpha, this.CreateSourceAlpha);
+            Buffer.Add(SvgFilterPrimitive.SourceGraphic, CreateSourceGraphic);
+            Buffer.Add(SvgFilterPrimitive.SourceAlpha, CreateSourceAlpha);
         }
 
         #region Defaults
 
         private void ResetDefaults()
         {
-            if (this.sourceGraphic != null)
+            if (sourceGraphic != null)
             {
-                this.sourceGraphic.Dispose();
-                this.sourceGraphic = null;
+                sourceGraphic.Dispose();
+                sourceGraphic = null;
             }
 
-            if (this.sourceAlpha != null)
+            if (sourceAlpha != null)
             {
-                this.sourceAlpha.Dispose();
-                this.sourceAlpha = null;
+                sourceAlpha.Dispose();
+                sourceAlpha = null;
             }
         }
 
         private Bitmap CreateSourceGraphic(SvgVisualElement element, SvgRenderer renderer)
         {
-            if (this.sourceGraphic == null)
+            if (sourceGraphic == null)
             {
                 RectangleF bounds = element.Path.GetBounds();
-                this.sourceGraphic = new Bitmap((int)bounds.Width, (int)bounds.Height);
+                sourceGraphic = new Bitmap((int)bounds.Width, (int)bounds.Height);
 
-                using (var graphics = Graphics.FromImage(this.sourceGraphic))
+                using (Graphics graphics = Graphics.FromImage(sourceGraphic))
                 {
                     graphics.Clip = renderer.Clip;
                     graphics.Transform = renderer.Transform;
@@ -134,7 +134,7 @@
 
         private Bitmap CreateSourceAlpha(SvgVisualElement element, SvgRenderer renderer)
         {
-            if (this.sourceAlpha == null)
+            if (sourceAlpha == null)
             {
                 Bitmap source = this.Buffer[SvgFilterPrimitive.SourceGraphic](element, renderer);
 
@@ -145,14 +145,14 @@
                    new float[] {0, 0, 0, 1, 1},        // alpha
                    new float[] {0, 0, 0, 0, 0} };    // translations
 
-                var matrix = new ColorMatrix(colorMatrixElements);
+                ColorMatrix matrix = new ColorMatrix(colorMatrixElements);
 
                 ImageAttributes attributes = new ImageAttributes();
                 attributes.SetColorMatrix(matrix);
 
-                this.sourceAlpha = new Bitmap(source.Width, source.Height);
+                sourceAlpha = new Bitmap(source.Width, source.Height);
 
-                using (var graphics = Graphics.FromImage(this.sourceAlpha))
+                using (Graphics graphics = Graphics.FromImage(sourceAlpha))
                 {
 
                     graphics.DrawImage(source, new Rectangle(0, 0, source.Width, source.Height), 0, 0,
@@ -161,7 +161,7 @@
                 }
             }
 
-            return this.sourceAlpha;
+            return sourceAlpha;
         }
         #endregion
     }
Index: Filter Effects/SvgFilterPrimitive.cs
===================================================================
--- Filter Effects/SvgFilterPrimitive.cs	(revision 75832)
+++ Filter Effects/SvgFilterPrimitive.cs	(working copy)
@@ -18,20 +18,20 @@
         [SvgAttribute("in")]
         public string Input
         {
-            get { return this.Attributes.GetAttribute<string>("in"); }
-            set { this.Attributes["in"] = value; }
+            get { return Attributes.GetAttribute<string>("in"); }
+            set { Attributes["in"] = value; }
         }
 
         [SvgAttribute("result")]
         public string Result
         {
-            get { return this.Attributes.GetAttribute<string>("result"); }
-            set { this.Attributes["result"] = value; }
+            get { return Attributes.GetAttribute<string>("result"); }
+            set { Attributes["result"] = value; }
         }
 
         protected SvgFilter Owner
         {
-            get { return (SvgFilter)this.Parent; }
+            get { return (SvgFilter)Parent; }
         }
 
         public abstract Bitmap Process();
Index: Painting/SvgGradientServer.cs
===================================================================
--- Painting/SvgGradientServer.cs	(revision 75832)
+++ Painting/SvgGradientServer.cs	(working copy)
@@ -12,9 +12,8 @@
     /// </summary>
     public abstract class SvgGradientServer : SvgPaintServer
     {
-        private SvgCoordinateUnits _gradientUnits;
         private SvgGradientSpreadMethod _spreadMethod = SvgGradientSpreadMethod.Pad;
-        private SvgGradientServer _inheritGradient;
+		private SvgGradientServer _inheritGradient;
         private List<SvgGradientStop> _stops;
 
         /// <summary>
@@ -62,7 +61,14 @@
         /// </summary>
         public List<SvgGradientStop> Stops
         {
-            get { return this._stops; }
+            get
+            {
+                if (_stops.Count == 0 && InheritGradient != null)
+                {
+                    return InheritGradient.Stops;
+                }
+                return _stops;
+            }
         }
 
         /// <summary>
@@ -79,11 +85,7 @@
         /// Gets or sets the coordinate system of the gradient.
         /// </summary>
         [SvgAttribute("gradientUnits")]
-        public SvgCoordinateUnits GradientUnits
-        {
-            get { return this._gradientUnits; }
-            set { this._gradientUnits = value; }
-        }
+        public SvgCoordinateUnits GradientUnits { get; set; }
 
         /// <summary>
         /// Gets or sets another gradient fill from which to inherit the stops from.
@@ -106,8 +108,11 @@
         /// <param name="opacity">The opacity of the colour blend.</param>
         protected ColorBlend GetColourBlend(SvgVisualElement owner, float opacity)
         {
+			int colourBlends = this.Stops.Count;
+            if (colourBlends <= 0)
+                return null;
+				
             ColorBlend blend = new ColorBlend();
-            int colourBlends = this.Stops.Count;
             bool insertStart = false;
             bool insertEnd = false;
 
@@ -142,27 +147,27 @@
             float position = 0.0f;
             Color colour = Color.Black;
 
-            for (int i = 0; i < colourBlends; i++)
+            for (int i = colourBlends - 1; i >= 0; i--)
             {
                 mergedOpacity = opacity * this.Stops[actualStops].Opacity;
-                position = (this.Stops[actualStops].Offset.ToDeviceValue(owner) / owner.Bounds.Width);
+                position = (1.0f - this.Stops[actualStops].Offset.ToDeviceValue(owner) / owner.Bounds.Width);
                 colour = Color.FromArgb((int)(mergedOpacity * 255), this.Stops[actualStops++].Colour);
 
                 // Insert this colour before itself at position 0
-                if (insertStart && i == 0)
+				if (insertStart && i == colourBlends - 1)
                 {
-                    blend.Positions[i] = 0.0f;
-                    blend.Colors[i++] = colour;
+                    blend.Positions[i] = 1f;
+                    blend.Colors[i--] = colour;
                 }
 
                 blend.Positions[i] = position;
                 blend.Colors[i] = colour;
 
                 // Insert this colour after itself at position 0
-                if (insertEnd && i == colourBlends - 2)
+                if (insertEnd && i == 1)
                 {
-                    blend.Positions[i + 1] = 1.0f;
-                    blend.Colors[++i] = colour;
+                    blend.Positions[i - 1] = 0f;
+                    blend.Colors[--i] = colour;
                 }
             }
 
Index: Painting/SvgGradientStop.cs
===================================================================
--- Painting/SvgGradientStop.cs	(revision 75832)
+++ Painting/SvgGradientStop.cs	(working copy)
@@ -13,8 +13,6 @@
     public class SvgGradientStop : SvgElement
     {
         private SvgUnit _offset;
-        private Color _colour;
-        private float _opacity;
 
         /// <summary>
         /// Gets or sets the offset, i.e. where the stop begins from the beginning, of the gradient stop.
@@ -34,21 +32,13 @@
         /// </summary>
         [SvgAttribute("stop-color")]
         [TypeConverter(typeof(SvgColourConverter))]
-        public Color Colour
-        {
-            get { return this._colour; }
-            set { this._colour = value; }
-        }
+        public Color Colour { get; set; }
 
         /// <summary>
         /// Gets or sets the opacity of the gradient stop (0-1).
         /// </summary>
         [SvgAttribute("stop-opacity")]
-        public float Opacity
-        {
-            get { return this._opacity; }
-            set { this._opacity = value; }
-        }
+        public float Opacity { get; set; }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SvgGradientStop"/> class.
@@ -56,8 +46,8 @@
         public SvgGradientStop()
         {
             this._offset = new SvgUnit(0.0f);
-            this._colour = Color.Transparent;
-            this._opacity = 1.0f;
+            Colour = Color.Transparent;
+            Opacity = 1.0f;
         }
 
         /// <summary>
@@ -68,8 +58,8 @@
         public SvgGradientStop(SvgUnit offset, Color colour)
         {
             this._offset = offset;
-            this._colour = colour;
-            this._opacity = 1.0f;
+            Colour = colour;
+            Opacity = 1.0f;
         }
     }
 }
\ No newline at end of file
Index: Painting/SvgLinearGradientServer.cs
===================================================================
--- Painting/SvgLinearGradientServer.cs	(revision 75832)
+++ Painting/SvgLinearGradientServer.cs	(working copy)
@@ -10,67 +10,35 @@
     [SvgElement("linearGradient")]
     public sealed class SvgLinearGradientServer : SvgGradientServer
     {
-        private SvgUnit _x1;
-        private SvgUnit _y1;
-        private SvgUnit _x2;
-        private SvgUnit _y2;
 
         [DefaultValue(typeof(SvgUnit), "0"), SvgAttribute("x1")]
-        public SvgUnit X1
-        {
-            get { return this._x1; }
-            set
-            {
-                this._x1 = value;
-            }
-        }
+        public SvgUnit X1 { get; set; }
 
         [DefaultValue(typeof(SvgUnit), "0"), SvgAttribute("y1")]
-        public SvgUnit Y1
-        {
-            get { return this._y1; }
-            set
-            {
-                this._y1 = value;
-            }
-        }
+        public SvgUnit Y1 { get; set; }
 
         [DefaultValue(typeof(SvgUnit), "0"), SvgAttribute("x2")]
-        public SvgUnit X2
-        {
-            get { return this._x2; }
-            set
-            {
-                this._x2 = value;
-            }
-        }
+        public SvgUnit X2 { get; set; }
 
         [DefaultValue(typeof(SvgUnit), "0"), SvgAttribute("y2")]
-        public SvgUnit Y2
-        {
-            get { return this._y2; }
-            set
-            {
-                this._y2 = value;
-            }
-        }
+        public SvgUnit Y2 { get; set; }
 
         public SvgLinearGradientServer()
         {
-            this._x1 = new SvgUnit(0.0f);
-            this._y1 = new SvgUnit(0.0f);
-            this._x2 = new SvgUnit(0.0f);
-            this._y2 = new SvgUnit(0.0f);
+            X1 = new SvgUnit(0.0f);
+            Y1 = new SvgUnit(0.0f);
+            X2 = new SvgUnit(0.0f);
+            Y2 = new SvgUnit(0.0f);
         }
 
         public SvgPoint Start
         {
-            get { return new SvgPoint(this.X1, this.Y1); }
+            get { return new SvgPoint(X1, Y1); }
         }
 
         public SvgPoint End
         {
-            get { return new SvgPoint(this.X2, this.Y2); }
+            get { return new SvgPoint(X2, Y2); }
         }
 
         public override Brush GetBrush(SvgVisualElement owner, float opacity)
Index: Painting/SvgPaintServerFactory.cs
===================================================================
--- Painting/SvgPaintServerFactory.cs	(revision 75832)
+++ Painting/SvgPaintServerFactory.cs	(working copy)
@@ -40,7 +40,11 @@
             }
             else // Otherwise try and parse as colour
             {
-                return new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Trim()));
+				String val = value.Trim();
+                SvgPaintServer server = (SvgPaintServer)document.IdManager.GetElementById(val);
+                if (server == null)
+                    server = new SvgColourServer((Color)_colourConverter.ConvertFrom(val));
+                return server;
             }
         }
 
Index: Painting/SvgRadialGradientServer.cs
===================================================================
--- Painting/SvgRadialGradientServer.cs	(revision 75832)
+++ Painting/SvgRadialGradientServer.cs	(working copy)
@@ -45,6 +45,17 @@
         }
 
         /// <summary>
+        /// Gets or sets the element transforms.
+        /// </summary>
+        /// <value>The transforms.</value>
+        [SvgAttribute("gradientTransform")]
+        public SvgTransformCollection GradientTransforms
+        {
+            get { return this.Attributes.GetAttribute<SvgTransformCollection>("Transforms"); }
+            set { this.Attributes["Transforms"] = value; }
+        }
+
+        /// <summary>
         /// Initializes a new instance of the <see cref="SvgRadialGradientServer"/> class.
         /// </summary>
         public SvgRadialGradientServer()
@@ -61,19 +72,56 @@
             float left = this.CenterX.ToDeviceValue(renderingElement);
             float top = this.CenterY.ToDeviceValue(renderingElement, true);
             float radius = this.Radius.ToDeviceValue(renderingElement);
+
             RectangleF boundingBox = (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) ? renderingElement.Bounds : renderingElement.OwnerDocument.GetDimensions();
 
             if (radius > 0)
             {
-                path.AddEllipse(left - radius, top - radius, radius * 2, radius * 2);
+				path.AddEllipse(left-radius, top-radius, radius*2, radius*2);
 
-                PathGradientBrush brush = new PathGradientBrush(path);
-                ColorBlend blend = base.GetColourBlend(renderingElement, opacity);
-
-                brush.InterpolationColors = blend;
-                brush.CenterPoint = new PointF(this.FocalX.ToDeviceValue(renderingElement), this.FocalY.ToDeviceValue(renderingElement, true));
-
-                return brush;
+				// Computing the total gradient transformation (if any)
+				var matrix = new Matrix();
+	
+				if (GradientTransforms != null)
+				{
+					foreach (SvgTransform tr in GradientTransforms)
+					{      
+						matrix.Multiply(tr.Matrix, MatrixOrder.Append);
+					}
+				}
+	
+				// .. and applying it to the path
+				path.Transform(matrix);
+	
+				PathGradientBrush brush = new PathGradientBrush(path);
+				ColorBlend blend = base.GetColourBlend(renderingElement, opacity);
+	
+				if (blend != null)
+					brush.InterpolationColors = blend;
+	
+				// According to http://www.w3.org/TR/2000/CR-SVG-20000802/pservers.html#RadialGradients
+				// the focal point must be modified if it lies outside the circle defined by cp and radius:
+				var fp = new PointF(FocalX.ToDeviceValue(renderingElement),
+									FocalY.ToDeviceValue(renderingElement, true));
+				var cp = new PointF(left, top);
+	
+				float dx = fp.X - cp.X;
+				float dy = fp.Y - cp.Y;
+				var d = (float)Math.Sqrt(dx*dx + dy*dy);
+				
+				if (d > radius)
+				{
+					fp = new PointF(cp.X + ((fp.X - cp.X)*radius)/d,
+									cp.Y + ((fp.Y - cp.Y)*radius)/d);
+				}
+	
+				// The gradient transformation must be applied to the focal point as well:
+				var toTr = new[] {fp};
+				matrix.TransformPoints(toTr);
+	
+				brush.CenterPoint = toTr[0];
+			
+				return brush;
             }
             
             return null;            
Index: Svg.csproj
===================================================================
--- Svg.csproj	(revision 75832)
+++ Svg.csproj	(working copy)
@@ -11,31 +11,11 @@
     <RootNamespace>Svg</RootNamespace>
     <AssemblyName>Svg</AssemblyName>
     <RunPostBuildEvent>OnOutputUpdated</RunPostBuildEvent>
-    <FileUpgradeFlags>
-    </FileUpgradeFlags>
     <OldToolsVersion>3.5</OldToolsVersion>
-    <UpgradeBackupLocation>
-    </UpgradeBackupLocation>
     <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
-    <IsWebBootstrapper>false</IsWebBootstrapper>
-    <SccProjectName>SAK</SccProjectName>
-    <SccLocalPath>SAK</SccLocalPath>
-    <SccAuxPath>SAK</SccAuxPath>
-    <SccProvider>SAK</SccProvider>
-    <PublishUrl>publish\</PublishUrl>
-    <Install>true</Install>
-    <InstallFrom>Disk</InstallFrom>
-    <UpdateEnabled>false</UpdateEnabled>
-    <UpdateMode>Foreground</UpdateMode>
-    <UpdateInterval>7</UpdateInterval>
-    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
-    <UpdatePeriodically>false</UpdatePeriodically>
-    <UpdateRequired>false</UpdateRequired>
-    <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
     <UseApplicationTrust>false</UseApplicationTrust>
-    <BootstrapperEnabled>true</BootstrapperEnabled>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -71,6 +51,7 @@
     <Reference Include="System.Xml" />
   </ItemGroup>
   <ItemGroup>
+    <Compile Include="Basic Shapes\SvgVisibility.cs" />
     <Compile Include="Basic Shapes\SvgVisualElement.cs" />
     <Compile Include="Basic Shapes\SvgCircle.cs" />
     <Compile Include="Basic Shapes\SvgEllipse.cs" />
Index: SvgDocument.cs
===================================================================
--- SvgDocument.cs	(revision 75832)
+++ SvgDocument.cs	(working copy)
@@ -165,7 +165,7 @@
 
             //Trace.TraceInformation("Begin Read");
 
-            using (var reader = new SvgTextReader(stream, entities))
+            using (XmlTextReader reader = new SvgTextReader(stream, entities))
             {
                 var elementStack = new Stack<SvgElement>();
                 var value = new StringBuilder();
@@ -173,8 +173,6 @@
                 SvgElement element = null;
                 SvgElement parent;
                 SvgDocument svgDocument = null;
-                reader.XmlResolver = new SvgDtdResolver();
-                reader.WhitespaceHandling = WhitespaceHandling.None;
 
                 while (reader.Read())
                 {
@@ -183,8 +181,6 @@
                         switch (reader.NodeType)
                         {
                             case XmlNodeType.Element:
-                                // Does this element have a value or children
-                                // (Must do this check here before we progress to another node)
                                 elementEmpty = reader.IsEmptyElement;
                                 // Create element
                                 if (elementStack.Count > 0)
@@ -228,7 +224,7 @@
                                 }
                                 // Pop the element out of the stack
                                 element = elementStack.Pop();
-
+                                
                                 if (value.Length > 0)
                                 {
                                     element.Content = value.ToString();
@@ -238,7 +234,16 @@
                                 break;
                             case XmlNodeType.CDATA:
                             case XmlNodeType.Text:
-                                value.Append(reader.Value);
+                                var text = reader.Value;
+                                if (reader.XmlSpace != XmlSpace.Preserve)
+                                {
+                                    text = text.Replace("\t", " ");
+                                    text = text.Replace("\n", string.Empty);
+                                    text = text.Replace("\r", string.Empty);
+                                    text = text.Replace("  ", " ");
+                                    text = text.Trim();
+                                }
+                                value.Append(text);
                                 break;
                         }
                     }
@@ -310,8 +315,14 @@
             {
                 throw new ArgumentNullException("graphics");
             }
-
-            this.Render(SvgRenderer.FromGraphics(graphics));
+			
+			try
+            {
+                Render(SvgRenderer.FromGraphics(graphics));
+            }
+            catch
+            { 
+			}
         }
 
         /// <summary>
@@ -323,11 +334,11 @@
             //Trace.TraceInformation("Begin Render");
 
             var size = GetDimensions();
-            var bitmap = new Bitmap((int)Math.Ceiling(size.Width), (int)Math.Ceiling(size.Height));
+            Bitmap bitmap = new Bitmap((int)Math.Ceiling(size.Width), (int)Math.Ceiling(size.Height));
 
             try
             {
-                using (var renderer = SvgRenderer.FromImage(bitmap))
+                using (SvgRenderer renderer = SvgRenderer.FromImage(bitmap))
                 {
                     renderer.TextRenderingHint = TextRenderingHint.AntiAlias;
                     renderer.TextContrast = 1;
@@ -336,10 +347,10 @@
                     renderer.Save();
                 }
             }
-            catch
+            catch (Exception ex)
             {
                 bitmap.Dispose();
-                throw;
+                throw ex;
             }
 
             //Trace.TraceInformation("End Render");
Index: SvgElement.cs
===================================================================
--- SvgElement.cs	(revision 75832)
+++ SvgElement.cs	(working copy)
@@ -15,11 +15,9 @@
     /// </summary>
     public abstract class SvgElement : ISvgElement, ISvgTransformable, ICloneable
     {
-        internal SvgElement _parent;
         private string _elementName;
         private SvgAttributeCollection _attributes;
         private EventHandlerList _eventHandlers;
-        private SvgElementCollection _children;
         private static readonly object _loadEventKey = new object();
         private Matrix _graphicsMatrix;
 
@@ -74,10 +72,7 @@
         /// <summary>
         /// Gets a collection of all child <see cref="SvgElements"/>.
         /// </summary>
-        public virtual SvgElementCollection Children
-        {
-            get { return this._children; }
-        }
+        public virtual SvgElementCollection Children { get; private set; }
 
         /// <summary>
         /// Gets a value to determine whether the element has children.
@@ -91,10 +86,7 @@
         /// Gets the parent <see cref="SvgElement"/>.
         /// </summary>
         /// <value>An <see cref="SvgElement"/> if one exists; otherwise null.</value>
-        public virtual SvgElement Parent
-        {
-            get { return this._parent; }
-        }
+        public virtual SvgElement Parent { get; internal set; }
 
         /// <summary>
         /// Gets the owner <see cref="SvgDocument"/>.
@@ -128,12 +120,12 @@
         {
             get
             {
-                if (this._attributes == null)
+                if (_attributes == null)
                 {
-                    this._attributes = new SvgAttributeCollection(this);
+                    _attributes = new SvgAttributeCollection(this);
                 }
 
-                return this._attributes;
+                return _attributes;
             }
         }
 
@@ -146,7 +138,7 @@
             _graphicsMatrix = renderer.Transform;
 
             // Return if there are no transforms
-            if (this.Transforms == null || this.Transforms.Count == 0)
+            if (Transforms == null || Transforms.Count == 0)
             {
                 return;
             }
@@ -194,10 +186,10 @@
         /// </summary>
         /// <value>The transforms.</value>
         [SvgAttribute("transform")]
-        public SvgTransformCollection Transforms
+        public virtual SvgTransformCollection Transforms
         {
-            get { return this.Attributes.GetAttribute<SvgTransformCollection>("Transforms"); }
-            set { this.Attributes["Transforms"] = value; }
+            get { return Attributes.GetAttribute<SvgTransformCollection>("Transforms"); }
+            set { Attributes["Transforms"] = value; }
         }
 
         /// <summary>
@@ -247,7 +239,7 @@
         /// <param name="index">An <see cref="int"/> representing the index where the element was added to the collection.</param>
         internal void OnElementAdded(SvgElement child, int index)
         {
-            this.AddElement(child, index);
+            AddElement(child, index);
         }
 
         /// <summary>
@@ -265,7 +257,7 @@
         /// <param name="child">The <see cref="SvgElement"/> that has been removed.</param>
         internal void OnElementRemoved(SvgElement child)
         {
-            this.RemoveElement(child);
+            RemoveElement(child);
         }
 
         /// <summary>
@@ -273,7 +265,7 @@
         /// </summary>
         internal SvgElement()
         {
-            this._children = new SvgElementCollection(this);
+            Children = new SvgElementCollection(this);
             this._eventHandlers = new EventHandlerList();
             this._elementName = string.Empty;
         }
@@ -356,9 +348,9 @@
         /// <param name="renderer">The <see cref="SvgRenderer"/> object to render to.</param>
         protected virtual void Render(SvgRenderer renderer)
         {
-            this.PushTransforms(renderer);
-            this.RenderChildren(renderer);
-            this.PopTransforms(renderer);
+            PushTransforms(renderer);
+            RenderChildren(renderer);
+            PopTransforms(renderer);
         }
 
         /// <summary>
@@ -367,7 +359,7 @@
         /// <param name="renderer">The <see cref="SvgRenderer"/> to render the child <see cref="SvgElement"/>s to.</param>
         protected virtual void RenderChildren(SvgRenderer renderer)
         {
-            foreach (SvgElement element in this.Children)
+            foreach (SvgElement element in Children)
             {
                 element.Render(renderer);
             }
Index: SvgElementCollection.cs
===================================================================
--- SvgElementCollection.cs	(revision 75832)
+++ SvgElementCollection.cs	(working copy)
@@ -80,10 +80,10 @@
                     this._owner.OwnerDocument.IdManager.Add(item);
                 }
 
-                item._parent = this._owner;
+                item.Parent = this._owner;
             }
 
-            item._parent.OnElementAdded(item, this.Count - 1);
+            item.Parent.OnElementAdded(item, this.Count - 1);
 
             this._elements.Add(item);
         }
@@ -127,7 +127,7 @@
 
                 if (!this._mock)
                 {
-                    item._parent = null;
+                    item.Parent = null;
 
                     if (this._owner.OwnerDocument != null)
                     {
Index: SvgElementFactory.cs
===================================================================
--- SvgElementFactory.cs	(revision 75832)
+++ SvgElementFactory.cs	(working copy)
@@ -5,6 +5,7 @@
 using System.ComponentModel;
 using System.Diagnostics;
 using System.Linq;
+using System.Drawing;
 
 namespace Svg
 {
@@ -13,6 +14,15 @@
     /// </summary>
     internal class SvgElementFactory
     {
+        static SvgElementFactory()
+        {
+            //Required for Font assigment logic.
+            var converter = new FontConverter().ConvertFrom("-") as Font;
+            defaultFontName = converter.Name;
+            converter.Dispose();
+        }
+
+        private static string defaultFontName;
         private static List<ElementInfo> availableElements;
 
         /// <summary>
@@ -42,7 +52,7 @@
         /// <param name="reader">The <see cref="XmlTextReader"/> containing the node to parse into an <see cref="SvgDocument"/>.</param>
         /// <exception cref="ArgumentNullException">The <paramref name="reader"/> parameter cannot be <c>null</c>.</exception>
         /// <exception cref="InvalidOperationException">The CreateDocument method can only be used to parse root &lt;svg&gt; elements.</exception>
-        public static SvgDocument CreateDocument(XmlTextReader reader)
+        public static SvgDocument CreateDocument(SvgTextReader reader)
         {
             if (reader == null)
             {
@@ -63,7 +73,7 @@
         /// <param name="reader">The <see cref="XmlTextReader"/> containing the node to parse into a subclass of <see cref="SvgElement"/>.</param>
         /// <param name="document">The <see cref="SvgDocument"/> that the created element belongs to.</param>
         /// <exception cref="ArgumentNullException">The <paramref name="reader"/> and <paramref name="document"/> parameters cannot be <c>null</c>.</exception>
-        public static SvgElement CreateElement(XmlTextReader reader, SvgDocument document)
+        public static SvgElement CreateElement(SvgTextReader reader, SvgDocument document)
         {
             if (reader == null)
             {
@@ -78,7 +88,7 @@
             return CreateElement(reader, false, document);
         }
 
-        private static SvgElement CreateElement(XmlTextReader reader, bool fragmentIsDocument, SvgDocument document)
+        private static SvgElement CreateElement(SvgTextReader reader, bool fragmentIsDocument, SvgDocument document)
         {
             SvgElement createdElement = null;
             string elementName = reader.LocalName;
@@ -109,12 +119,14 @@
             return createdElement;
         }
 
-        private static void SetAttributes(SvgElement element, XmlTextReader reader, SvgDocument document)
+        private static void SetAttributes(SvgElement element, SvgTextReader reader, SvgDocument document)
         {
             //Trace.TraceInformation("Begin SetAttributes");
 
             string[] styles = null;
             string[] style = null;
+            string[] values = null;
+
             int i = 0;
 
             while (reader.MoveToNextAttribute())
@@ -132,7 +144,8 @@
                         }
 
                         style = styles[i].Split(new char[] { ':' }, StringSplitOptions.RemoveEmptyEntries);
-                        SetPropertyValue(element, style[0].Trim(), style[1].Trim(), document);
+                        values = style[1].Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
+                        SetPropertyValue(element, style[0].Trim(), values, document);
                     }
 
                     continue;
@@ -146,8 +159,23 @@
 
         private static Dictionary<Type, Dictionary<string, PropertyDescriptorCollection>> _propertyDescriptors = new Dictionary<Type, Dictionary<string, PropertyDescriptorCollection>>();
 
-        private static void SetPropertyValue(SvgElement element, string attributeName, string attributeValue, SvgDocument document)
+        private static void SetPropertyValue(SvgElement element, string attributeName, string[] attributeValues, SvgDocument document)
         {
+            foreach (var value in attributeValues)
+            {
+                //Make sure each value is formatted correctly.
+                //Remove leading/trailing spaces and remove single quotes
+                var formattedValue = value.Trim().Replace("'", string.Empty);
+
+                if (SetPropertyValue(element, attributeName, formattedValue, document))
+                {
+                    break;
+                }
+            }
+        }
+
+        private static bool SetPropertyValue(SvgElement element, string attributeName, string attributeValue, SvgDocument document)
+        {
             var elementType = element.GetType();
 
             PropertyDescriptorCollection properties;
@@ -174,16 +202,27 @@
             if (properties.Count > 0)
             {
                 PropertyDescriptor descriptor = properties[0];
+                var convertedValue = descriptor.Converter.ConvertFrom(document, CultureInfo.InvariantCulture, attributeValue);
 
+                // Special treatment for Font-Family: if what was requested wasn't produced
+                if ((descriptor.PropertyType == typeof(Font)) 
+                    && (defaultFontName != attributeValue) 
+                    && (((Font)convertedValue).Name == defaultFontName))
+                {
+                    return false;
+                }
+
                 try
                 {
-                    descriptor.SetValue(element, descriptor.Converter.ConvertFrom(document, CultureInfo.InvariantCulture, attributeValue));
+                    descriptor.SetValue(element, convertedValue);
                 }
                 catch
                 {
                     Trace.TraceWarning(string.Format("Attribute '{0}' cannot be set - type '{1}' cannot convert from string '{2}'.", attributeName, descriptor.PropertyType.FullName, attributeValue));
                 }
             }
+
+            return true;
         }
 
         /// <summary>
Index: SvgTextReader.cs
===================================================================
--- SvgTextReader.cs	(revision 75832)
+++ SvgTextReader.cs	(working copy)
@@ -8,18 +8,25 @@
 
 namespace Svg
 {
-    internal sealed class SvgTextReader : XmlTextReader
+    internal sealed class SvgTextReader : IDisposable
     {
         private Dictionary<string, string> _entities;
         private string _value;
         private bool _customValue = false;
         private string _localName;
+        private XmlReader _reader;
 
         public SvgTextReader(Stream stream, Dictionary<string, string> entities)
-            : base(stream)
         {
-            this.EntityHandling = EntityHandling.ExpandCharEntities;
-            this._entities = entities;
+            XmlReaderSettings settings = new XmlReaderSettings();
+            settings.ConformanceLevel = ConformanceLevel.Document;
+            settings.IgnoreWhitespace = false;
+            settings.IgnoreComments = true;
+            settings.IgnoreProcessingInstructions = false;
+
+            settings.XmlResolver = new SvgDtdResolver();
+            _reader = XmlReader.Create(stream, settings);
+            _entities = entities;
         }
 
         /// <summary>
@@ -27,11 +34,11 @@
         /// </summary>
         /// <value></value>
         /// <returns>The value returned depends on the <see cref="P:System.Xml.XmlTextReader.NodeType"/> of the node. The following table lists node types that have a value to return. All other node types return String.Empty.Node Type Value AttributeThe value of the attribute. CDATAThe content of the CDATA section. CommentThe content of the comment. DocumentTypeThe internal subset. ProcessingInstructionThe entire content, excluding the target. SignificantWhitespaceThe white space within an xml:space= 'preserve' scope. TextThe content of the text node. WhitespaceThe white space between markup. XmlDeclarationThe content of the declaration. </returns>
-        public override string Value
+        public string Value
         {
             get
             {
-                return (this._customValue) ? this._value : base.Value;
+                return (this._customValue) ? this._value : this._reader.Value;
             }
         }
 
@@ -40,11 +47,11 @@
         /// </summary>
         /// <value></value>
         /// <returns>The name of the current node with the prefix removed. For example, LocalName is book for the element &lt;bk:book&gt;.For node types that do not have a name (like Text, Comment, and so on), this property returns String.Empty.</returns>
-        public override string LocalName
+        public string LocalName
         {
             get
             {
-                return (this._customValue) ? this._localName : base.LocalName;
+                return (this._customValue) ? this._localName : this._reader.LocalName;
             }
         }
 
@@ -61,29 +68,45 @@
             }
         }
 
+        public XmlNodeType NodeType
+        {
+            get
+            {
+                return this._reader.NodeType;
+            }
+        }
+
+        public bool IsEmptyElement
+        {
+            get
+            {
+                return this._reader.IsEmptyElement;
+            }
+        }
+
         /// <summary>
         /// Moves to the next attribute.
         /// </summary>
         /// <returns>
         /// true if there is a next attribute; false if there are no more attributes.
         /// </returns>
-        public override bool MoveToNextAttribute()
+        public bool MoveToNextAttribute()
         {
-            bool moved = base.MoveToNextAttribute();
+            bool moved = this._reader.MoveToNextAttribute();
 
             if (moved)
             {
-                this._localName = base.LocalName;
+                this._localName = this._reader.LocalName;
 
-                if (this.ReadAttributeValue())
+                if (this._reader.ReadAttributeValue())
                 {
-                    if (this.NodeType == XmlNodeType.EntityReference)
+                    if (this._reader.NodeType == XmlNodeType.EntityReference)
                     {
                         this.ResolveEntity();
                     }
                     else
                     {
-                        this._value = base.Value;
+                        this._value = this._reader.Value;
                     }
                 }
                 this._customValue = true;
@@ -99,12 +122,12 @@
         /// true if the next node was read successfully; false if there are no more nodes to read.
         /// </returns>
         /// <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML. </exception>
-        public override bool Read()
+        public bool Read()
         {
             this._customValue = false;
-            bool read = base.Read();
+            bool read = this._reader.Read();
 
-            if (this.NodeType == XmlNodeType.DocumentType)
+            if (this._reader.NodeType == XmlNodeType.DocumentType)
             {
                 this.ParseEntities();
             }
@@ -129,7 +152,7 @@
 
                 parts = entity.Trim().Split(new char[]{' ', '\t'},  StringSplitOptions.RemoveEmptyEntries);
                 name = parts[0];
-                value = parts[1].Split(new char[] { this.QuoteChar }, StringSplitOptions.RemoveEmptyEntries)[0];
+                value = parts[1].Split(new char[] { this._reader.QuoteChar }, StringSplitOptions.RemoveEmptyEntries)[0];
 
                 this.Entities.Add(name, value);
             }
@@ -138,13 +161,13 @@
         /// <summary>
         /// Resolves the entity reference for EntityReference nodes.
         /// </summary>
-        public override void ResolveEntity()
+        public void ResolveEntity()
         {
-            if (this.NodeType == XmlNodeType.EntityReference)
+            if (this._reader.NodeType == XmlNodeType.EntityReference)
             {
-                if (this._entities.ContainsKey(this.Name))
+                if (this._entities.ContainsKey(this._reader.Name))
                 {
-                    this._value = this._entities[this.Name];
+                    this._value = this._entities[this._reader.Name];
                 }
                 else
                 {
@@ -154,5 +177,23 @@
                 this._customValue = true;
             }
         }
+
+        public XmlSpace XmlSpace
+        {
+            get
+            {
+                return _reader.XmlSpace;
+            }
+        }
+
+        #region IDisposable Members
+
+        public void Dispose()
+        {
+            if (this._reader != null)
+                ((IDisposable)this._reader).Dispose();
+        }
+
+        #endregion
     }
 }
\ No newline at end of file
Index: Text/SvgText.cs
===================================================================
--- Text/SvgText.cs	(revision 75832)
+++ Text/SvgText.cs	(working copy)
@@ -121,7 +121,11 @@
         public virtual Font FontFamily
         {
             get { return this._font; }
-            set { this._font = value; this.IsPathDirty = true; }
+			set 
+            {
+                this._font = value;
+                this.IsPathDirty = true; 
+            }
         }
 
         /// <summary>
@@ -141,7 +145,11 @@
         public virtual Font Font
         {
             get { return this._font; }
-            set { this._font = value; this.IsPathDirty = true; }
+            set 
+			{
+				this._font = value; 
+				this.IsPathDirty = true; 
+			}
         }
 
         /// <summary>
@@ -203,7 +211,7 @@
             get
             {
                 // Make sure the path is always null if there is no text
-                if (_path == null || this.IsPathDirty && !string.IsNullOrEmpty(this.Text))
+                if ((_path == null || this.IsPathDirty) && !string.IsNullOrEmpty(this.Text))
                 {
                     float fontSize = this.FontSize.ToDeviceValue(this);
                     if (fontSize == 0.0f)
@@ -220,11 +228,11 @@
                             location = new PointF(this.X.ToDeviceValue(this), this.Y.ToDeviceValue(this, true) - fontSize);
                             break;
                         case SvgTextAnchor.Middle:
-                            stringWidth = SvgText.MeasureString(_stringMeasure, this.Text, new Font(this._font.FontFamily, fontSize));
+                            stringWidth = SvgText.MeasureString(_stringMeasure, this.Text, new Font(Font.FontFamily, fontSize));
                             location = new PointF(this.X.ToDeviceValue(this) - (stringWidth / 2), this.Y.ToDeviceValue(this, true) - fontSize);
                             break;
                         case SvgTextAnchor.End:
-                            stringWidth = SvgText.MeasureString(_stringMeasure, this.Text, new Font(this._font.FontFamily, fontSize));
+                            stringWidth = SvgText.MeasureString(_stringMeasure, this.Text, new Font(Font.FontFamily, fontSize));
                             location = new PointF(this.X.ToDeviceValue(this) - stringWidth, this.Y.ToDeviceValue(this, true) - fontSize);
                             break;
                     }
@@ -249,13 +257,13 @@
                                 char[] characters = word.ToCharArray();
                                 foreach (char currentCharacter in characters)
                                 {
-                                    _path.AddString(currentCharacter.ToString(), this._font.FontFamily, 0, fontSize, location, StringFormat.GenericTypographic);
+                                    _path.AddString(currentCharacter.ToString(), Font.FontFamily, 0, fontSize, location, StringFormat.GenericTypographic);
                                     location = new PointF(_path.GetBounds().Width + start + letterSpacing, location.Y);
                                 }
                             }
                             else
                             {
-                                _path.AddString(word, this._font.FontFamily, 0, fontSize, location, StringFormat.GenericTypographic);
+                                _path.AddString(word, Font.FontFamily, 0, fontSize, location, StringFormat.GenericTypographic);
                             }
 
                             // Move the location of the word to be written along
@@ -266,7 +274,7 @@
                     {
                         if (!string.IsNullOrEmpty(this.Text))
                         {
-                            _path.AddString(this.Text, this._font.FontFamily, 0, fontSize, location, StringFormat.GenericTypographic);
+                            _path.AddString(this.Text, Font.FontFamily, 0, fontSize, location, StringFormat.GenericTypographic);
                         }
                     }
 
Index: Text/SvgTextSpan.cs
===================================================================
--- Text/SvgTextSpan.cs	(revision 75832)
+++ Text/SvgTextSpan.cs	(working copy)
@@ -3,6 +3,7 @@
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
+using Svg.Transforms;
 
 namespace Svg
 {
@@ -16,8 +17,14 @@
         [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
         public override SvgUnit X
         {
-            get { return base.X; }
-            set { base.X = value; }
+            get 
+			{
+				return ((base.X.Type == SvgUnitType.None) ? ParentNode.X : base.X);
+			}
+            set
+			{
+				base.X = value; 
+			}
         }
 
         /// <summary>
@@ -27,8 +34,144 @@
         [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
         public override SvgUnit Y
         {
-            get { return base.Y; }
-            set { base.Y = value; }
+            get 
+			{ 
+				return ((base.Y.Type == SvgUnitType.None) ? ParentNode.Y : base.Y);
+			}
+            set 
+			{
+				base.Y = value;
+			}
         }
+		
+		public SvgTextSpan() : base()
+        {
+		}
+
+        public SvgTextSpan(string text) : base(text)
+        {
+		}
+
+        private SvgText ParentNode
+        {
+            get { return (SvgText) Parent; }
+        }
+
+        public override System.Drawing.Font Font
+        {
+            get { return ParentNode.Font; }
+        }
+
+        public override SvgUnit FontSize
+        {
+            get { return ParentNode.FontSize; }
+        }
+
+        public override SvgPaintServer Fill
+        {
+            get { return ParentNode.Fill; }
+        }
+
+        public override SvgUnit LetterSpacing
+        {
+            get { return ParentNode.LetterSpacing; }
+        }
+
+        public override float Opacity
+        {
+            get { return ParentNode.Opacity; }
+        }
+
+        public override SvgTextAnchor TextAnchor
+        {
+            get { return ParentNode.TextAnchor; }
+        }
+
+        public override Uri ClipPath
+        {
+            get { return ParentNode.ClipPath; }
+        }
+
+        public override float FillOpacity
+        {
+            get { return ParentNode.FillOpacity; }
+        }
+
+        public override SvgFillRule FillRule
+        {
+            get { return ParentNode.FillRule; }
+        }
+
+        public override System.Drawing.Font FontFamily
+        {
+            get { return ParentNode.FontFamily; }
+        }
+
+        public override SvgPaintServer Stroke
+        {
+            get { return ParentNode.Stroke; }
+        }
+
+        public override SvgUnitCollection StrokeDashArray
+        {
+            get { return ParentNode.StrokeDashArray; }
+        }
+
+        public override SvgUnit StrokeDashOffset
+        {
+            get { return ParentNode.StrokeDashOffset; }
+        }
+
+        public override SvgStrokeLineCap StrokeLineCap
+        {
+            get { return ParentNode.StrokeLineCap; }
+        }
+
+        public override SvgStrokeLineJoin StrokeLineJoin
+        {
+            get { return ParentNode.StrokeLineJoin; }
+        }
+
+        public override float StrokeMiterLimit
+        {
+            get { return ParentNode.StrokeMiterLimit; }
+        }
+
+        public override float StrokeOpacity
+        {
+            get { return ParentNode.StrokeOpacity; }
+        }
+
+        public override SvgUnit StrokeWidth
+        {
+            get { return ParentNode.StrokeWidth; }
+        }
+
+        public override bool Visible
+        {
+            get { return ParentNode.Visible; }
+        }
+
+        public override SvgUnit WordSpacing
+        {
+            get { return ParentNode.WordSpacing; }
+        }
+
+        public override SvgTransformCollection Transforms
+        {
+            get
+            {
+                if (base.Transforms == null || base.Transforms.Count == 0)
+                {
+                    return Parent.Transforms;
+                }
+
+                return base.Transforms;
+            }
+            set
+            {
+                base.Transforms = value;
+            }
+        }
     }
 }
\ No newline at end of file
